// This is your Prisma schema file

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// NextAuth.js Models
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
  annotations   Annotation[]

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([email])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Annotation {
  id                String   @id @default(cuid())

  // User relationship
  userId            String
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Video identifiers
  videoId           String   // Format: V{vendor}_S{session}_I{interaction}
  vendorId          Int
  sessionId         Int
  interactionId     Int

  // Speakers (participants in the interaction)
  speaker1Id        String   // Participant 1 ID (can be alphanumeric, e.g., "0799", "0299A")
  speaker2Id        String   // Participant 2 ID (can be alphanumeric, e.g., "0799", "0299A")

  // Labels (morphs A/B)
  speaker1Label     String   // Morph label for speaker 1
  speaker2Label     String   // Morph label for speaker 2

  // Confidence (per speaker)
  speaker1Confidence Int     @default(3) // 1-5 scale for speaker 1
  speaker2Confidence Int     @default(3) // 1-5 scale for speaker 2

  // Comments (per speaker)
  speaker1Comments  String?  @default("")
  speaker2Comments  String?  @default("")

  // Metadata
  labelingTimeMs    Int      @default(0) // Time taken to label in milliseconds

  // Timestamps
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Composite unique constraint: one annotation per user per video
  @@unique([userId, videoId])
  @@index([videoId])
  @@index([userId])
  @@index([createdAt])
}

model Video {
  id              String   @id @default(cuid())

  // Video identifiers
  videoId         String   @unique // Format: V{vendor}_S{session}_I{interaction}
  vendorId        Int
  sessionId       Int
  interactionId   Int

  // Participants
  participant1Id  String   // Can be alphanumeric (e.g., "0799", "0299A")
  participant2Id  String   // Can be alphanumeric

  // Dataset metadata
  label           String   // 'improvised' or 'naturalistic'
  split           String   // 'train', 'dev', or 'test'

  // File references (used to construct streaming URLs)
  fileId1         String   // Full file ID for participant 1
  fileId2         String   // Full file ID for participant 2

  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([videoId])
  @@index([label, split])
  @@index([vendorId, sessionId, interactionId])
}
